### ES6- 变量的解构赋值

@(ES6)

###### 数组的结构赋值
1. 如果解构不成功,变量的值等于undefined;
2. 解构赋值允许指定默认值,但 只有当一个数组成员严格等于undefined,默认值才会生效

```javascript
let [x=f()]=[1];  //函数 f()不会执行

```
3. 默认值可以引用结构赋值的其他变量,但必须是已经定义了的
4. 属性是有次序的,和值一一对应

###### 对象的解构赋值
1. 属性没有次序
2. 变量必须与对象的属性同名,才能取到值
3. 对象的解构赋值,可以方便地将现有对象的方法,赋值到某个变量

```js
let {log,sin,cos} = Math;
```
4. 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者
```JS
let { foo: baz } = { foo: "aaa", bar: "bbb" };
baz // "aaa"
foo // error: foo is not defined
```
5. 如果解构不成功,变量的值等于undefined;
6. 也可以用来指定默认值

###### 字符串的解构赋值
1. 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。
```
const [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"

```
###### 函数参数的解构赋值
1. 函数参数的解构也可以使用默认值。
```js
function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
```
2. 如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况
```javascript
function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError: Cannot read property 'x' of undefined
```


###### 解构赋值的用处
- 交换变量的值
```javascript
let x=1,y=2;
[x,y]=[2,1];
```

- 取出从函数中返回的多个值
- 函数参数的定义
- 提取json数据
- 函数参数的默认值
- 遍历Map结构
> 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。
